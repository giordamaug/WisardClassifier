%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{WisardClassifier Documentation}
\date{Mar 06, 2018}
\release{beta}
\author{Maurizio Giordano}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}

\index{WisardClassifier (class in wis)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:wis.WisardClassifier}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{wis.}\sphinxbfcode{WisardClassifier}}{\emph{n\_bits=8}, \emph{n\_tics=256}, \emph{mapping='random'}, \emph{debug=False}, \emph{bleaching=True}, \emph{default\_bleaching=1}, \emph{confidence\_bleaching=0.01}, \emph{n\_jobs=1}, \emph{random\_state=0}}{}
Wisard Classifier.

This model uses the WiSARD weightless neural network.
WiSARD stands for “Wilkie, Stonham, Aleksander Recognition Device”.
It is a weightless neural network model to recognize binary patterns.
For a introduction to WiSARD, please read a brief introduction to
weightless neural network (\sphinxurl{https://www.elen.ucl.ac.be/Proceedings/esann/esannpdf/es2009-6.pdf})
\begin{description}
\item[{n\_bits}] \leavevmode{[}int, optional, default 8{]}
number of bits used in n-tuple extraction from input (network resolution),
should be in {[}1, 32{]}

\item[{n\_tics}] \leavevmode{[}int, optional, default 256{]}
datum sclaling factor (e.g. max discretization value)
high values slow down system perfromance

\item[{mapping}] \leavevmode{[}\{‘linear’, ‘random’\}, optional, default ‘random’{]}
input to neurons mapping

\item[{bleaching}] \leavevmode{[}bool, optional, default True{]}
enable bleaching algorithm to solve classification ties

\item[{default\_bleaching}] \leavevmode{[}integer, optional, default 1{]}
bleaching variable step

\item[{confidence\_bleaching}] \leavevmode{[}floar, optional, default 0.01{]}
bleaching confidence tie paramater,
should be in range {]}1, 0{]}

\item[{n\_jobs}] \leavevmode{[}integer, optional (default=1){]}
The number of jobs to run in parallel for both \sphinxtitleref{fit} and \sphinxtitleref{predict}.
If -1, then the number of jobs is set to the number of cores.
random\_state : int, or 0, optional, default None
If int, random\_state is the seed used by the random number generator;
If 0, the random number generator is the RandomState instance used

\item[{by \sphinxtitleref{np.random}.}] \leavevmode
debug : bool, optional, default True
enable debugging

\end{description}
\begin{description}
\item[{{\color{red}\bfseries{}wiznet\_}}] \leavevmode{[}dictionary{]}
The set of WiSARD discriminators (one for each class)

\item[{{\color{red}\bfseries{}nrams\_}}] \leavevmode{[}int{]}
The number of RAMs in each discriminato

\item[{{\color{red}\bfseries{}nclasses\_}}] \leavevmode{[}int{]}
The number of classes

\item[{{\color{red}\bfseries{}nfeatures\_}}] \leavevmode{[}int{]}
The number of features (variable) in the datum

\item[{{\color{red}\bfseries{}ranges\_}}] \leavevmode{[}array of shape = {[}{\color{red}\bfseries{}nfeatures\_}{]}{]}
The range of features (variables) in the datum

\item[{{\color{red}\bfseries{}offsets\_}}] \leavevmode{[}array of shape = {[}{\color{red}\bfseries{}nfeatures\_}{]}{]}
The offsets of features (variables) in the datum

\item[{{\color{red}\bfseries{}classes\_}}] \leavevmode{[}array of shape = {[}{\color{red}\bfseries{}nclasses\_}{]}{]}
The set of classes

\item[{{\color{red}\bfseries{}npixels\_}}] \leavevmode{[}int{]}
The number of pixels in input binarized

\item[{{\color{red}\bfseries{}progress\_}}] \leavevmode{[}float{]}
Progress bar monitoring step, default 0.0

\item[{{\color{red}\bfseries{}starttm\_}}] \leavevmode{[}int{]}
Progress bar monitoring time starter

\end{description}

Here you find a simple example of using WisardClassifier in Python.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{wis} \PYG{k}{import} \PYG{n}{WisardClassifier}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{datasets} \PYG{k}{import} \PYG{n}{make\PYGZus{}classification}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{make\PYGZus{}classification}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{n\PYGZus{}features}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
\PYG{g+gp}{... }                           \PYG{n}{n\PYGZus{}informative}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n\PYGZus{}redundant}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{g+gp}{... }                           \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{shuffle}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{clf} \PYG{o}{=} \PYG{n}{WisardClassifier}\PYG{p}{(}\PYG{n}{n\PYGZus{}bits}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{n\PYGZus{}tics}\PYG{o}{=}\PYG{l+m+mi}{128}\PYG{p}{,} \PYG{n}{debug}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{clf}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{g+go}{train \textbar{}XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\textbar{} 100 \PYGZpc{}  00:00:00 00:00:00}
\PYG{g+go}{WisardClassifier(bleaching=True, confidence\PYGZus{}bleaching=0.01, debug=True,}
\PYG{g+go}{default\PYGZus{}bleaching=1, mapping=\PYGZsq{}random\PYGZsq{}, n\PYGZus{}bits=4, n\PYGZus{}jobs=1,}
\PYG{g+go}{n\PYGZus{}tics=128, random\PYGZus{}state=0)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{clf}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[1]}
\end{sphinxVerbatim}

The default values for the parameters controlling the number of bits (‘’n\_bits’‘)
and the datum scaling range (‘’n\_btics’‘) are set in order to have an averaged
high accuracy on several classification problems.
By using parallel computation you only affect classification stage. Model fitting does not
exploit multcore yet.
To obtain a deterministic behaviour during
fitting, \sphinxcode{random\_state} has to be fixed.
For more information, please read .. {[}1{]}
\index{fit() (wis.WisardClassifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:wis.WisardClassifier.fit}}\pysiglinewithargsret{\sphinxbfcode{fit}}{\emph{X}, \emph{y}}{}
Fit the WiSARD model to data matrix X and target(s) y.

X : array-like or sparse matrix, shape (n\_samples, n\_features)
The input data.
y : array-like, shape (n\_samples,) or (n\_samples, n\_outputs)
The target values (class labels in classification, real numbers in
regression).

self : returns a trained WiSARD model.

\end{fulllineitems}

\index{get\_params() (wis.WisardClassifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:wis.WisardClassifier.get_params}}\pysiglinewithargsret{\sphinxbfcode{get\_params}}{\emph{deep=True}}{}
Get parameters for this estimator.
\begin{description}
\item[{deep}] \leavevmode{[}boolean, optional{]}
If True, will return the parameters for this estimator and
contained subobjects that are estimators.

\end{description}
\begin{description}
\item[{params}] \leavevmode{[}mapping of string to any{]}
Parameter names mapped to their values.

\end{description}

\end{fulllineitems}

\index{predict() (wis.WisardClassifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:wis.WisardClassifier.predict}}\pysiglinewithargsret{\sphinxbfcode{predict}}{\emph{X}}{}
Predict using the WiSARD model.
\begin{description}
\item[{X}] \leavevmode{[}\{array-like, sparse matrix\}, shape (n\_samples, n\_features){]}
The input data.

\end{description}
\begin{description}
\item[{y}] \leavevmode{[}array-like, shape (n\_samples, n\_outputs){]}
The predicted values.

\end{description}

\end{fulllineitems}

\index{set\_params() (wis.WisardClassifier method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:wis.WisardClassifier.set_params}}\pysiglinewithargsret{\sphinxbfcode{set\_params}}{\emph{**parameters}}{}
Set the parameters of this estimator.
The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
\sphinxcode{\textless{}component\textgreater{}\_\_\textless{}parameter\textgreater{}} so that it’s possible to update each
component of a nested object.

self : returns the WiSARD model.

\end{fulllineitems}


\end{fulllineitems}



\chapter{WisardClassifier’s usage in scikit learn}
\label{\detokenize{index:wisardclassifier-s-documentation}}\label{\detokenize{index:wisardclassifier-s-usage-in-scikit-learn}}
The following is an exampleof usage of WisardClassifier in the Scikit Learn
library.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}import numpy library}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{c+c1}{\PYGZsh{} import sklearn and scipy stuff}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn.datasets} \PYG{k+kn}{import} \PYG{n}{load\PYGZus{}svmlight\PYGZus{}file}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{n}{cross\PYGZus{}validation}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn.metrics} \PYG{k+kn}{import} \PYG{n}{confusion\PYGZus{}matrix}\PYG{p}{,} \PYG{n}{accuracy\PYGZus{}score}
\PYG{k+kn}{import} \PYG{n+nn}{scipy.sparse} \PYG{k+kn}{as} \PYG{n+nn}{sps}
\PYG{k+kn}{from} \PYG{n+nn}{scipy.io} \PYG{k+kn}{import} \PYG{n}{arff}
\PYG{c+c1}{\PYGZsh{} import wisard classifier library}
\PYG{k+kn}{from} \PYG{n+nn}{wis} \PYG{k+kn}{import} \PYG{n}{WisardClassifier}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{c+c1}{\PYGZsh{}import utilities for matplot}
\PYG{k+kn}{from}  \PYG{n+nn}{utilities} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} (Try) import matplot for graphics}
\PYG{k}{try}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}
    \PYG{n}{matplotfound} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{k}{except} \PYG{n+ne}{ImportError}\PYG{p}{:}
    \PYG{n}{matplotfound} \PYG{o}{=} \PYG{n+nb+bp}{False}
    \PYG{k}{pass}

\PYG{n}{B\PYGZus{}enabled} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{c+c1}{\PYGZsh{} IRIS (arff) \PYGZhy{} load datasets}
\PYG{n}{data}\PYG{p}{,} \PYG{n}{meta} \PYG{o}{=} \PYG{n}{arff}\PYG{o}{.}\PYG{n}{loadarff}\PYG{p}{(}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{datasets/iris.arff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{y\PYGZus{}train} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{class}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{X\PYGZus{}train} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{[}\PYG{n}{meta}\PYG{o}{.}\PYG{n}{\PYGZus{}attrnames}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{X\PYGZus{}train} \PYG{o}{=} \PYG{n}{X\PYGZus{}train}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{sps}\PYG{o}{.}\PYG{n}{issparse}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{)} \PYG{k}{else} \PYG{n}{X\PYGZus{}train}  \PYG{c+c1}{\PYGZsh{} avoid sparse data}
\PYG{n}{class\PYGZus{}names} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} IRIS (arff) \PYGZhy{} cross validation example}
\PYG{n}{clf} \PYG{o}{=} \PYG{n}{WisardClassifier}\PYG{p}{(}\PYG{n}{n\PYGZus{}bits}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{n}{bleaching}\PYG{o}{=}\PYG{n}{B\PYGZus{}enabled}\PYG{p}{,}\PYG{n}{n\PYGZus{}tics}\PYG{o}{=}\PYG{l+m+mi}{256}\PYG{p}{,}\PYG{n}{mapping}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{debug}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{default\PYGZus{}bleaching}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{kf} \PYG{o}{=} \PYG{n}{cross\PYGZus{}validation}\PYG{o}{.}\PYG{n}{LeaveOneOut}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{class\PYGZus{}names}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{predicted} \PYG{o}{=} \PYG{n}{cross\PYGZus{}validation}\PYG{o}{.}\PYG{n}{cross\PYGZus{}val\PYGZus{}score}\PYG{p}{(}\PYG{n}{clf}\PYG{p}{,} \PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}train}\PYG{p}{,} \PYG{n}{cv}\PYG{o}{=}\PYG{n}{kf}\PYG{p}{,} \PYG{n}{n\PYGZus{}jobs}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Accuracy Avg: }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{predicted}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} IRIS (libsvm) \PYGZhy{} load datasets}
\PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}train} \PYG{o}{=} \PYG{n}{load\PYGZus{}svmlight\PYGZus{}file}\PYG{p}{(}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{datasets/iris.libsvm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{class\PYGZus{}names} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{)}
\PYG{n}{X\PYGZus{}train} \PYG{o}{=} \PYG{n}{X\PYGZus{}train}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{sps}\PYG{o}{.}\PYG{n}{issparse}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{)} \PYG{k}{else} \PYG{n}{X\PYGZus{}train}  \PYG{c+c1}{\PYGZsh{} avoid sparse data}
\PYG{c+c1}{\PYGZsh{} IRIS \PYGZhy{} cross validation example (with fixed seed)}
\PYG{n}{clf} \PYG{o}{=} \PYG{n}{WisardClassifier}\PYG{p}{(}\PYG{n}{n\PYGZus{}bits}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{n}{n\PYGZus{}tics}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{debug}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{bleaching}\PYG{o}{=}\PYG{n}{B\PYGZus{}enabled}\PYG{p}{,}\PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{848484848}\PYG{p}{)}
\PYG{n}{kf} \PYG{o}{=} \PYG{n}{cross\PYGZus{}validation}\PYG{o}{.}\PYG{n}{StratifiedKFold}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{predicted} \PYG{o}{=} \PYG{n}{cross\PYGZus{}validation}\PYG{o}{.}\PYG{n}{cross\PYGZus{}val\PYGZus{}score}\PYG{p}{(}\PYG{n}{clf}\PYG{p}{,} \PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}train}\PYG{p}{,} \PYG{n}{cv}\PYG{o}{=}\PYG{n}{kf}\PYG{p}{,} \PYG{n}{n\PYGZus{}jobs}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Accuracy Avg: }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{predicted}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} DNA (libsvm) \PYGZhy{} load datasets}
\PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}train} \PYG{o}{=} \PYG{n}{load\PYGZus{}svmlight\PYGZus{}file}\PYG{p}{(}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{datasets/dna.tr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{X\PYGZus{}train} \PYG{o}{=} \PYG{n}{X\PYGZus{}train}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{sps}\PYG{o}{.}\PYG{n}{issparse}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{)} \PYG{k}{else} \PYG{n}{X\PYGZus{}train}  \PYG{c+c1}{\PYGZsh{} avoid sparse data}
\PYG{n}{class\PYGZus{}names} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{)}
\PYG{n}{X\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}test} \PYG{o}{=} \PYG{n}{load\PYGZus{}svmlight\PYGZus{}file}\PYG{p}{(}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{datasets/dna.t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{X\PYGZus{}test} \PYG{o}{=} \PYG{n}{X\PYGZus{}test}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{sps}\PYG{o}{.}\PYG{n}{issparse}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{)} \PYG{k}{else} \PYG{n}{X\PYGZus{}test}  \PYG{c+c1}{\PYGZsh{} avoid sparse data}

\PYG{c+c1}{\PYGZsh{} DNA (arff) \PYGZhy{} testing example}
\PYG{n}{clf} \PYG{o}{=} \PYG{n}{WisardClassifier}\PYG{p}{(}\PYG{n}{n\PYGZus{}bits}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{n}{n\PYGZus{}tics}\PYG{o}{=}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{n}{debug}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{bleaching}\PYG{o}{=}\PYG{n}{B\PYGZus{}enabled}\PYG{p}{,}\PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{848484848}\PYG{p}{,}\PYG{n}{n\PYGZus{}jobs}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{clf}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}train}\PYG{p}{)}
\PYG{n}{tm} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{clf}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time: }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{tm}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{predicted} \PYG{o}{=} \PYG{n}{accuracy\PYGZus{}score}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}
\PYG{n}{cm} \PYG{o}{=} \PYG{n}{confusion\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Accuracy: }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{predicted}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} DNA \PYGZhy{} plot (print) confusion matrix}
\PYG{k}{if} \PYG{n}{matplotfound}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plot\PYGZus{}confusion\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{cm}\PYG{p}{,} \PYG{n}{classes}\PYG{o}{=}\PYG{n}{class\PYGZus{}names}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Confusion matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{print\PYGZus{}confmatrix}\PYG{p}{(}\PYG{n}{cm}\PYG{p}{)}

\end{sphinxVerbatim}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}